https://leetcode.com/problems/rotting-oranges/description/
class Solution {
public:
    int orangesRotting(vector<vector<int>>& grid) {
        queue<pair<pair<int, int>,int>> q;
        int m=grid.size(), n=grid[0].size(), cnt=0, maxTime=0, cnt1=0;
        vector<vector<int>> vis(m, vector<int>(n, 0));
        for(int i=0; i<m; i++){
            for(int j=0; j<n; j++){
                // pushing all the rotten oranges in the q
                if(grid[i][j]==2) q.push({{i, j}, 0});
                else if(grid[i][j]==1) cnt++;
                // counting the fresh oranges
            }
        }

        while(!q.empty()){
            auto it=q.front();
            int row=it.first.first;
            int col=it.first.second;
            int time=it.second;
            q.pop();
            // storing max time for all oranges to be rotten
            // the orange that will rott in the end will give us the max time
            // but we can not find the last orage that will be rotten
            maxTime=max(time, maxTime);
            int del[]={-1, 0, 1, 0, -1};
            for(int i=0; i<4; i++){
                int nrow=row+del[i];
                int ncol=col+del[i+1];
                if(nrow>=0 && ncol>=0 && nrow<m && ncol<n){
                    if(grid[nrow][ncol]==1 && !vis[nrow][ncol]){
                        // pushing every fresh oranges with time++ in q
                        q.push({{nrow, ncol}, time+1});
                        vis[nrow][ncol]=1;
                        cnt1++;
                        // counting the no fresh oranges we had made rotten
                    }
                }
            }
        }
        if(cnt==cnt1) return maxTime;
        return -1;
    }
};
// graph by madhur
