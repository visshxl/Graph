https://www.geeksforgeeks.org/problems/number-of-distinct-islands/0
class Solution {
  public:
  // sr and sc are source row and source cols, from where the first dfs call for every
  // new island has been called
  void dfs(int sr, int sc, int row, int col, vector<vector<int>>& grid, vector<vector<int>>& vis, vector<pair<int, int>>& shape){
      vis[row][col]=1;
        // use pen and paper to dry run, it will push the identical values for the island
        //   of same shapes and we are pushing those shapes in a set
      shape.push_back({sr-row, sc-col});

      int del[]={-1, 0, 1, 0, -1};
      for(int i=0; i<4; i++){
          int nrow=row+del[i];
          int ncol=col+del[i+1];
          if(nrow>=0 && ncol>=0 && nrow<grid.size() && ncol<grid[0].size()){
              if(grid[nrow][ncol]==1 && !vis[nrow][ncol]){
                  dfs(sr, sc, nrow, ncol, grid, vis, shape);
              }
          }
      }
  }
    
    int countDistinctIslands(vector<vector<int>>& grid) {
        int m=grid.size(), n=grid[0].size();
        set<vector<pair<int, int>>> st;
        vector<vector<int>> vis(m, vector<int>(n, 0));
        // calling dfs for each unvisited 1 same as in number of islands
        for(int i=0; i<m; i++){
            for(int j=0; j<n; j++){
                if(grid[i][j]==1 && !vis[i][j]){
                    vector<pair<int, int>> shape;
                    dfs(i, j, i, j, grid, vis, shape);
                    st.insert(shape);
                }
            }
        }
        return st.size();
    }
};
// graph by madhur
